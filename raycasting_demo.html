<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Raycast Door Interaction</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            pointer-events: none;
            border: 1px solid #0f0;
            z-index: 10;
            font-size: 14px;
            line-height: 1.5;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #dcdcdc;
            text-align: center;
            background: rgba(40, 40, 30, 0.95);
            padding: 20px;
            border: 2px solid #8B7E66;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            max-width: 400px;
            width: 80%;
            z-index: 20;
        }

        #landscape-hint {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #C2B280;
            z-index: 999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        #light-switch {
            display: none;
        }

        @media screen and (orientation: portrait) {
            #landscape-hint.mobile-only {
                display: flex;
            }
        }

        h1 {
            color: #C2B280;
            margin-top: 0;
            text-shadow: 2px 2px 0 #000;
            font-size: 24px;
        }

        p {
            font-size: 14px;
            line-height: 1.5;
        }

        .key {
            color: #fff;
            font-weight: bold;
            background: #555;
            padding: 2px 5px;
            border-radius: 3px;
        }

        hr {
            border-color: #555;
            opacity: 0.5;
        }

        .status-row {
            color: #aaa;
            font-size: 12px;
            display: block;
        }

        .highlight {
            color: #fff;
            font-weight: bold;
        }
    </style>
</head>

<body>

    <div id="landscape-hint" class="mobile-only" style="display: none;">
        <h1>请旋转屏幕</h1>
        <p>需要横屏体验最佳视角</p>
    </div>

    <div id="ui">
        <div>FPS: <span id="fps">0</span> | Light: <span id="light-val">100%</span></div>
        <div class="status-row">Room: <span id="room-val" class="highlight">[?,?]</span></div>
        <div class="status-row">Door: <span id="door-val" style="color:#0f0">READY</span></div>
    </div>

    <div id="instructions">
        <h1>THE GAZE</h1>
        <p>交互系统升级</p>
        <p style="color:#ff6666; font-size:12px;">现在必须 <b>正对</b> 门才能打开</p>
        <hr>
        <div id="pc-controls">
            <p>点击屏幕锁定鼠标</p>
            <p><span class="key">WASD</span> 移动 | <span class="key">鼠标</span> 旋转</p>
        </div>
        <div id="mobile-controls" style="display:none;">
            <p>触摸控制已激活</p>
            <p>左屏：移动 | 右屏：旋转</p>
            <p style="color:#C2B280; font-weight:bold; margin-top:10px;">轻触此处开始</p>
        </div>
    </div>

    <canvas id="screen"></canvas>

    <script>
        /**
         * Textured Raycasting Engine (Look-at Interaction)
         * - Update: Doors only open if the player is LOOKING at them (center raycast).
         * - Doors still close automatically based on distance.
         */

        const canvas = document.getElementById('screen');
        const ctx = canvas.getContext('2d', { alpha: false });

        const uiFps = document.getElementById('fps');
        const uiLightVal = document.getElementById('light-val');
        const uiRoomVal = document.getElementById('room-val');
        const uiDoorVal = document.getElementById('door-val');
        const instructionBox = document.getElementById('instructions');
        const pcControls = document.getElementById('pc-controls');
        const mobileControls = document.getElementById('mobile-controls');
        const landscapeHint = document.getElementById('landscape-hint');

        let width, height;
        let lastTime = 0;

        const isMobile = (window.matchMedia && window.matchMedia("(pointer: coarse)").matches) || /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);

        // --- Game State ---
        const game = {
            doorCooldown: 0.0,
            maxCooldown: 3.0
        };

        // --- 1. 光照系统 ---
        const lighting = {
            targetLevel: 1.0,
            currentLevel: 1.0,
            minBrightness: 0.1,
            brightFogDist: 15.0,
            darkFogDist: 4.0,

            update(dt) {
                const speed = 3.0;
                const seconds = dt / 1000;

                if (this.currentLevel < this.targetLevel) {
                    this.currentLevel += speed * seconds;
                    if (this.currentLevel > this.targetLevel) this.currentLevel = this.targetLevel;
                } else if (this.currentLevel > this.targetLevel) {
                    this.currentLevel -= speed * seconds;
                    if (this.currentLevel < this.targetLevel) this.currentLevel = this.targetLevel;
                }

                uiLightVal.textContent = Math.round(this.currentLevel * 100) + "%";
            },

            setRoomState(isBright) {
                this.targetLevel = isBright ? 1.0 : 0.0;
            }
        };

        // --- 2. 纹理系统 ---
        const TEX_SIZE = 64;
        const textures = {};

        function generateTextures() {
            function createTexture(name, drawFn) {
                const c = document.createElement('canvas');
                c.width = TEX_SIZE;
                c.height = TEX_SIZE;
                const cx = c.getContext('2d');
                drawFn(cx, TEX_SIZE);
                textures[name] = c;
            }

            createTexture('wall', (cx, s) => {
                cx.fillStyle = '#C2B280';
                cx.fillRect(0, 0, s, s);
                for (let i = 0; i < 500; i++) {
                    const shade = Math.random();
                    cx.fillStyle = shade > 0.5 ? '#b0a070' : '#d4c490';
                    cx.globalAlpha = 0.3;
                    cx.fillRect(Math.random() * s, Math.random() * s, 2, 2);
                }
                cx.globalAlpha = 1.0;
                cx.fillStyle = 'rgba(0,0,0,0.03)';
                for (let i = 0; i < s; i += 8) cx.fillRect(i, 0, 2, s);
                cx.fillStyle = '#5d4037';
                cx.fillRect(0, s - 6, s, 6);
                cx.fillStyle = '#4a3028';
                cx.fillRect(0, s - 6, s, 1);
            });

            createTexture('door', (cx, s) => {
                cx.fillStyle = '#4a3020';
                cx.fillRect(0, 0, s, s);
                cx.fillStyle = 'rgba(0,0,0,0.2)';
                for (let i = 0; i < s; i += 2) {
                    if (Math.random() > 0.6) cx.fillRect(i, 0, 1, s);
                }
                cx.strokeStyle = '#2a1a10';
                cx.lineWidth = 3;
                cx.strokeRect(0, 0, s, s);
                cx.fillStyle = '#cccccc';
                cx.beginPath();
                cx.arc(s - 12, s / 2, 4, 0, Math.PI * 2);
                cx.fill();
                cx.fillStyle = '#888888';
                cx.beginPath();
                cx.arc(s - 12, s / 2, 4, Math.PI / 2, 3 * Math.PI / 2);
                cx.fill();
            });

            createTexture('jamb', (cx, s) => {
                cx.fillStyle = '#3e2b20';
                cx.fillRect(0, 0, s, s);
                cx.fillStyle = 'rgba(0,0,0,0.3)';
                for (let i = 0; i < s; i += 3) {
                    if (Math.random() > 0.5) cx.fillRect(i, 0, 1, s);
                }
            });
        }

        // --- 3. 游戏与门控系统 ---

        const MAP_SIZE = 42;
        const worldMap = [];
        const WALL_HEIGHT_SCALE = 3.0;
        const GRID_ROWS = 5;
        const GRID_COLS = 5;
        const CELL_SIZE = 8;
        const GRID_OFFSET = 1;

        const doorStates = {};
        const roomLightMap = [];

        function initMap() {
            for (let x = 0; x < MAP_SIZE; x++) worldMap[x] = new Uint8Array(MAP_SIZE);

            const startOffset = GRID_OFFSET;
            const endLimit = startOffset + GRID_ROWS * CELL_SIZE;

            for (let i = 0; i < GRID_ROWS; i++) {
                roomLightMap[i] = [];
                for (let j = 0; j < GRID_COLS; j++) {
                    if (i === 2 && j === 2) {
                        roomLightMap[i][j] = true;
                    } else {
                        roomLightMap[i][j] = Math.random() > 0.4;
                    }
                }
            }

            for (let x = startOffset; x <= endLimit; x++) {
                for (let y = startOffset; y <= endLimit; y++) {
                    const relX = x - startOffset;
                    const relY = y - startOffset;
                    const isVerticalWall = (relX % CELL_SIZE === 0);
                    const isHorizontalWall = (relY % CELL_SIZE === 0);

                    if (relX > GRID_ROWS * CELL_SIZE || relY > GRID_COLS * CELL_SIZE) continue;

                    if (isVerticalWall || isHorizontalWall) {
                        worldMap[x][y] = 1;
                        const isMidX = (relX % CELL_SIZE === CELL_SIZE / 2);
                        const isMidY = (relY % CELL_SIZE === CELL_SIZE / 2);

                        if ((isVerticalWall && isMidY && !isHorizontalWall && relX > 0 && relX < GRID_ROWS * CELL_SIZE) ||
                            (isHorizontalWall && isMidX && !isVerticalWall && relY > 0 && relY < GRID_COLS * CELL_SIZE)) {
                            worldMap[x][y] = 2; // 门
                            if (!doorStates[x]) doorStates[x] = {};
                            doorStates[x][y] = { offset: 0.0, state: 'CLOSED' };
                        }
                    }
                }
            }
        }

        function updateDoors(dt) {
            const seconds = dt / 1000;
            const openSpeed = 2.0;

            // 1. 更新 CD
            if (game.doorCooldown > 0) {
                game.doorCooldown -= seconds;
                if (game.doorCooldown < 0) game.doorCooldown = 0;
            }

            // 更新 UI
            if (game.doorCooldown > 0) {
                uiDoorVal.textContent = `CD ${game.doorCooldown.toFixed(1)}s`;
                uiDoorVal.style.color = '#ff4444';
            } else {
                uiDoorVal.textContent = "READY";
                uiDoorVal.style.color = '#44ff44';
            }

            // 2. 自动关门逻辑 & 动画更新 (遍历所有门)
            for (let x in doorStates) {
                for (let y in doorStates[x]) {
                    const door = doorStates[x][y];

                    // 距离检测 (仅用于关门)
                    const dx = player.x - (parseInt(x) + 0.5);
                    const dy = player.y - (parseInt(y) + 0.5);
                    const distSq = dx * dx + dy * dy;

                    // 修复：将关门阈值从 4.0 (2格) 提升到 9.0 (3格)
                    // 这样可以覆盖 MAX_INTERACT_DIST (2.5格)，防止门刚打开就因距离过远而自动关闭
                    if (distSq > 9.0) {
                        if (door.state === 'OPEN' || door.state === 'OPENING') {
                            door.state = 'CLOSING';
                        }
                    }

                    // 动画处理
                    if (door.state === 'OPENING') {
                        door.offset += openSpeed * seconds;
                        if (door.offset >= 1.0) { door.offset = 1.0; door.state = 'OPEN'; }
                    } else if (door.state === 'CLOSING') {
                        door.offset -= openSpeed * seconds;
                        if (door.offset <= 0.0) { door.offset = 0.0; door.state = 'CLOSED'; }
                    }
                }
            }

            // 3. 视线开门逻辑 (Raycast)
            // 只有当 CD 就绪时才检测
            if (game.doorCooldown <= 0) {
                // 发射一条交互射线，沿着玩家朝向
                let rX = player.x;
                let rY = player.y;
                let mX = Math.floor(rX);
                let mY = Math.floor(rY);

                // 防止除以0
                const rDirX = (player.dirX === 0) ? 0.00001 : player.dirX;
                const rDirY = (player.dirY === 0) ? 0.00001 : player.dirY;

                const deltaX = Math.abs(1 / rDirX);
                const deltaY = Math.abs(1 / rDirY);

                let stepX, stepY, sideX, sideY;

                if (rDirX < 0) { stepX = -1; sideX = (rX - mX) * deltaX; }
                else { stepX = 1; sideX = (mX + 1.0 - rX) * deltaX; }

                if (rDirY < 0) { stepY = -1; sideY = (rY - mY) * deltaY; }
                else { stepY = 1; sideY = (mY + 1.0 - rY) * deltaY; }

                let hit = false;
                let dist = 0;
                const MAX_INTERACT_DIST = 2.5; // 开门距离限制

                while (!hit && dist < MAX_INTERACT_DIST) {
                    if (sideX < sideY) {
                        sideX += deltaX;
                        mX += stepX;
                        dist = sideX - deltaX;
                    } else {
                        sideY += deltaY;
                        mY += stepY;
                        dist = sideY - deltaY;
                    }

                    // 边界检查
                    if (mX < 0 || mX >= MAP_SIZE || mY < 0 || mY >= MAP_SIZE) {
                        hit = true; break;
                    }

                    const tile = worldMap[mX][mY];
                    if (tile === 1) { // 撞墙停止
                        hit = true;
                    } else if (tile === 2) { // 发现门
                        hit = true;
                        // 尝试开门
                        const door = doorStates[mX]?.[mY];
                        if (door && (door.state === 'CLOSED' || door.state === 'CLOSING')) {
                            door.state = 'OPENING';
                            game.doorCooldown = game.maxCooldown; // 触发 CD
                        }
                    }
                }
            }
        }

        function getPlayerRoomIndex() {
            const gridX = Math.floor((player.x - GRID_OFFSET) / CELL_SIZE);
            const gridY = Math.floor((player.y - GRID_OFFSET) / CELL_SIZE);
            return { x: gridX, y: gridY };
        }

        const player = {
            x: 1 + 2 * 8 + 4.0,
            y: 1 + 2 * 8 + 4.0,
            dirX: -1, dirY: 0,
            planeX: 0, planeY: 0.80,
            rotSpeed: 0.002,
            moveSpeed: 0.08
        };

        const keys = { w: false, a: false, s: false, d: false };
        let isPointerLocked = false;
        let isGameActive = false;

        const COLORS_BASE = {
            ceiling: { r: 26, g: 26, b: 26 },
            floorFar: { r: 17, g: 17, b: 17 },
            floor: { r: 93, g: 85, b: 65 }
        };

        // --- 4. 输入系统 ---
        const touchInput = { moveId: null, startX: 0, startY: 0, currX: 0, currY: 0, lookId: null, lastLookX: 0 };

        function initInput() {
            if (isMobile) {
                pcControls.style.display = 'none';
                mobileControls.style.display = 'block';
                landscapeHint.classList.add('mobile-only');

                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

                instructionBox.addEventListener('click', () => {
                    instructionBox.style.display = 'none';
                    isGameActive = true;
                });
            } else {
                canvas.addEventListener('click', () => canvas.requestPointerLock());
                document.addEventListener('pointerlockchange', () => {
                    isPointerLocked = document.pointerLockElement === canvas;
                    instructionBox.style.display = isPointerLocked ? 'none' : 'block';
                    isGameActive = isPointerLocked;
                });
                document.addEventListener('mousemove', (e) => {
                    if (isPointerLocked) rotateCamera(-e.movementX * player.rotSpeed);
                });
                document.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true;
                });
                document.addEventListener('keyup', (e) => {
                    if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false;
                });
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const screenHalf = window.innerWidth / 2;
                if (t.pageX < screenHalf && touchInput.moveId === null) {
                    touchInput.moveId = t.identifier;
                    touchInput.startX = t.pageX; touchInput.startY = t.pageY;
                    touchInput.currX = t.pageX; touchInput.currY = t.pageY;
                } else if (t.pageX >= screenHalf && touchInput.lookId === null) {
                    touchInput.lookId = t.identifier;
                    touchInput.lastLookX = t.pageX;
                }
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (t.identifier === touchInput.moveId) {
                    touchInput.currX = t.pageX; touchInput.currY = t.pageY;
                    const deltaX = touchInput.currX - touchInput.startX;
                    const deltaY = touchInput.currY - touchInput.startY;
                    const threshold = 30;
                    keys.w = deltaY < -threshold; keys.s = deltaY > threshold;
                    keys.a = deltaX < -threshold; keys.d = deltaX > threshold;
                } else if (t.identifier === touchInput.lookId) {
                    const deltaX = t.pageX - touchInput.lastLookX;
                    rotateCamera(-deltaX * 0.005);
                    touchInput.lastLookX = t.pageX;
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (t.identifier === touchInput.moveId) {
                    touchInput.moveId = null;
                    keys.w = keys.s = keys.a = keys.d = false;
                }
                if (t.identifier === touchInput.lookId) touchInput.lookId = null;
            }
        }

        function resize() {
            const MAX_WIDTH = 960;
            const aspect = window.innerWidth / window.innerHeight;
            if (window.innerWidth > MAX_WIDTH) {
                width = MAX_WIDTH;
                height = Math.floor(MAX_WIDTH / aspect);
            } else {
                width = window.innerWidth;
                height = window.innerHeight;
            }
            canvas.width = width;
            canvas.height = height;
            ctx.imageSmoothingEnabled = false;
        }

        function init() {
            generateTextures();
            initMap();
            initInput();
            resize();
            window.addEventListener('resize', resize);
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            if (deltaTime > 0 && timestamp % 10 < 2) uiFps.textContent = Math.round(1000 / deltaTime);

            updateDoors(deltaTime);
            lighting.update(deltaTime);

            if (isGameActive || isMobile) update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            // --- 房间灯光检测 ---
            const roomIdx = getPlayerRoomIndex();
            // 确保索引在有效范围内 (0-4)
            if (roomIdx.x >= 0 && roomIdx.x < GRID_ROWS && roomIdx.y >= 0 && roomIdx.y < GRID_COLS) {
                const isRoomBright = roomLightMap[roomIdx.x][roomIdx.y];
                lighting.setRoomState(isRoomBright);
                uiRoomVal.textContent = `[${roomIdx.x},${roomIdx.y}] ${isRoomBright ? "LIGHT" : "DARK"}`;
            }

            // --- 物理更新 ---
            const checkCollision = (x, y) => {
                const mapX = Math.floor(x);
                const mapY = Math.floor(y);
                const tile = worldMap[mapX][mapY];
                if (tile === 1) return true;
                if (tile === 2) {
                    const door = doorStates[mapX]?.[mapY];
                    if (door && door.offset < 0.7) return true;
                }
                return false;
            };

            const r = 0.25;
            const collide = (x, y) => checkCollision(x, y) || checkCollision(x + r, y) || checkCollision(x - r, y) || checkCollision(x, y + r) || checkCollision(x, y - r);

            if (keys.w) {
                const newX = player.x + player.dirX * player.moveSpeed;
                const newY = player.y + player.dirY * player.moveSpeed;
                if (!collide(newX, player.y)) player.x = newX;
                if (!collide(player.x, newY)) player.y = newY;
            }
            if (keys.s) {
                const newX = player.x - player.dirX * player.moveSpeed;
                const newY = player.y - player.dirY * player.moveSpeed;
                if (!collide(newX, player.y)) player.x = newX;
                if (!collide(player.x, newY)) player.y = newY;
            }
            if (keys.d) {
                const strafeDirX = player.dirY; const strafeDirY = -player.dirX;
                const newX = player.x + strafeDirX * player.moveSpeed;
                const newY = player.y + strafeDirY * player.moveSpeed;
                if (!collide(newX, player.y)) player.x = newX;
                if (!collide(player.x, newY)) player.y = newY;
            }
            if (keys.a) {
                const strafeDirX = -player.dirY; const strafeDirY = player.dirX;
                const newX = player.x + strafeDirX * player.moveSpeed;
                const newY = player.y + strafeDirY * player.moveSpeed;
                if (!collide(newX, player.y)) player.x = newX;
                if (!collide(player.x, newY)) player.y = newY;
            }
        }

        function rotateCamera(angle) {
            const oldDirX = player.dirX;
            const oldPlaneX = player.planeX;
            player.dirX = player.dirX * Math.cos(angle) - player.dirY * Math.sin(angle);
            player.dirY = oldDirX * Math.sin(angle) + player.dirY * Math.cos(angle);
            player.planeX = player.planeX * Math.cos(angle) - player.planeY * Math.sin(angle);
            player.planeY = oldPlaneX * Math.sin(angle) + player.planeY * Math.cos(angle);
        }

        // --- 5. 渲染引擎 ---

        function draw() {
            const globalBrightness = lighting.minBrightness + lighting.currentLevel * (1.0 - lighting.minBrightness);
            const currentFogDist = lighting.darkFogDist + lighting.currentLevel * (lighting.brightFogDist - lighting.darkFogDist);

            const scaleColor = (c, factor) => `rgb(${Math.floor(c.r * factor)}, ${Math.floor(c.g * factor)}, ${Math.floor(c.b * factor)})`;

            ctx.fillStyle = scaleColor(COLORS_BASE.ceiling, globalBrightness);
            ctx.fillRect(0, 0, width, height / 2);

            const floorGradient = ctx.createLinearGradient(0, height / 2, 0, height);
            floorGradient.addColorStop(0, scaleColor(COLORS_BASE.floorFar, globalBrightness));
            floorGradient.addColorStop(1, scaleColor(COLORS_BASE.floor, globalBrightness));
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, height / 2, width, height / 2);

            for (let x = 0; x < width; x++) {
                const cameraX = 2 * x / width - 1;
                const rayDirX = player.dirX + player.planeX * cameraX;
                const rayDirY = player.dirY + player.planeY * cameraX;

                let mapX = Math.floor(player.x);
                let mapY = Math.floor(player.y);
                let sideDistX, sideDistY;
                const deltaDistX = (rayDirX === 0) ? 1e30 : Math.abs(1 / rayDirX);
                const deltaDistY = (rayDirY === 0) ? 1e30 : Math.abs(1 / rayDirY);
                let perpWallDist, stepX, stepY, hit = 0, side;

                if (rayDirX < 0) { stepX = -1; sideDistX = (player.x - mapX) * deltaDistX; }
                else { stepX = 1; sideDistX = (mapX + 1.0 - player.x) * deltaDistX; }
                if (rayDirY < 0) { stepY = -1; sideDistY = (player.y - mapY) * deltaDistY; }
                else { stepY = 1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; }

                let isDoor = false;
                let offset = 0;
                let doorOffset = 0;

                while (hit === 0) {
                    if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                    else { sideDistY += deltaDistY; mapY += stepY; side = 1; }

                    const tile = worldMap[mapX][mapY];

                    if (tile === 1) {
                        hit = 1;
                    }
                    else if (tile === 2) {
                        let distToBoundary = (side === 0) ? (sideDistX - deltaDistX) : (sideDistY - deltaDistY);
                        let distToMid = distToBoundary + (side === 0 ? deltaDistX : deltaDistY) * 0.5;
                        let hitPos = (side === 0) ? (player.y + rayDirY * distToMid) : (player.x + rayDirX * distToMid);
                        const mapIndex = (side === 0) ? mapY : mapX;

                        const doorObj = doorStates[mapX]?.[mapY];
                        const currentOpenAmount = doorObj ? doorObj.offset : 0.0;

                        if (hitPos >= mapIndex && hitPos <= (mapIndex + 1.0 - currentOpenAmount)) {
                            hit = 1;
                            isDoor = true;
                            perpWallDist = distToMid;
                            offset = hitPos - Math.floor(hitPos);
                            doorOffset = currentOpenAmount;
                        }
                    }
                }

                if (!isDoor) {
                    if (side === 0) perpWallDist = (sideDistX - deltaDistX);
                    else perpWallDist = (sideDistY - deltaDistY);
                }

                const lineHeight = Math.floor((height * WALL_HEIGHT_SCALE) / perpWallDist);
                let drawStart = -lineHeight / 2 + height / 2;

                let wallX;
                if (isDoor) {
                    wallX = offset + doorOffset;
                } else {
                    if (side == 0) wallX = player.y + perpWallDist * rayDirY;
                    else wallX = player.x + perpWallDist * rayDirX;
                    wallX -= Math.floor(wallX);
                }

                let texX = Math.floor(wallX * TEX_SIZE);
                if (side == 0 && rayDirX > 0) texX = TEX_SIZE - texX - 1;
                if (side == 1 && rayDirY < 0) texX = TEX_SIZE - texX - 1;

                let currentTexture = textures.wall;
                let isJamb = false;

                if (isDoor) {
                    currentTexture = textures.door;
                } else {
                    let prevX = mapX, prevY = mapY;
                    if (side === 0) prevX -= stepX;
                    else prevY -= stepY;

                    if (worldMap[prevX][prevY] === 2) {
                        currentTexture = textures.jamb;
                        isJamb = true;
                    }
                }

                ctx.drawImage(currentTexture, texX, 0, 1, TEX_SIZE, x, drawStart, 1, lineHeight);

                let brightness = 1.0 - (perpWallDist / currentFogDist);
                if (brightness < 0) brightness = 0;
                if (brightness > 1) brightness = 1;

                let geometricShade = 0;
                if (isJamb) geometricShade = 0.4;
                else if (!isDoor && side === 1) geometricShade = 0.25;

                let visibility = (1.0 - geometricShade) * brightness;
                let finalAlpha = 1.0 - (visibility * globalBrightness);

                if (finalAlpha > 0) {
                    if (finalAlpha > 0.98) finalAlpha = 0.98;
                    ctx.fillStyle = `rgba(0,0,0,${finalAlpha})`;
                    ctx.fillRect(x, drawStart, 1, lineHeight);
                }
            }

            drawCrosshair();
            if (isMobile && touchInput.moveId !== null) drawJoystick();
        }

        function drawCrosshair() {
            const cx = width / 2;
            const cy = height / 2;
            const size = 10;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - size, cy);
            ctx.lineTo(cx + size, cy);
            ctx.moveTo(cx, cy - size);
            ctx.lineTo(cx, cy + size);
            ctx.stroke();
        }

        function drawJoystick() {
            const scaleX = width / window.innerWidth;
            const scaleY = height / window.innerHeight;
            const startX = touchInput.startX * scaleX;
            const startY = touchInput.startY * scaleY;
            const currX = touchInput.currX * scaleX;
            const currY = touchInput.currY * scaleY;

            ctx.beginPath();
            ctx.arc(startX, startY, 50, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 4;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(currX, currY, 25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();
        }

        init();

    </script>
</body>

</html>